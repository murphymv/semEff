VIF(Shipley.SEM2)
VIF(lm(rnorm(100) ~ as.factor(rep(c("a", "b", "c", "d"), each = 25))))
xNam(lm(rnorm(100) ~ as.factor(rep(c("a", "b", "c", "d"), each = 25))), intercept = FALSE, aliased = FALSE)
semEff(Shipley.SEM2, ran.eff = "site", r.squared = TRUE,
R = 1000)
semEff(Shipley.SEM2.boot)
Shipley
Shipley.SEM <- list(
"DD" = lmer(DD ~ lat + (1 | site) + (1 | tree), data = Shipley),
"Date" = lmer(Date ~ lat + DD + (1 | site) + (1 | tree), data = Shipley),
"Growth" = lmer(Growth ~ lat + DD + Date + (1 | site) + (1 | tree),
data = Shipley),
"Live" = glmer(Live ~ lat + DD + Date + Growth + (1 | site) + (1 | tree),
family = binomial, data = Shipley)
)
Shipley.SEM <- list(
"DD" = lme4::lmer(DD ~ lat + (1 | site) + (1 | tree),
data = Shipley),
"Date" = lme4::lmer(Date ~ lat + DD + (1 | site) + (1 | tree),
data = Shipley),
"Growth" = lme4::lmer(Growth ~ lat + DD + Date + (1 | site) + (1 | tree),
data = Shipley),
"Live" = lme4::glmer(Live ~ lat + DD + Date + Growth + (1 | site)
+ (1 | tree), family = binomial, data = Shipley)
)
Shipley.SEM2.boot$DD$call
Shipley.Live <- list(
lme4::glmer(Live ~ Growth + (1 | site) + (1 | tree), binomial,
data = Shipley),
lme4::glmer(Live ~ Date + Growth + (1 | site) + (1 | tree), binomial,
data = Shipley),
lme4::glmer(Live ~ DD + Date + Growth + (1 | site) + (1 | tree),
binomial, data = Shipley),
lme4::glmer(Live ~ lat + DD + Date + Growth + (1 | site) + (1 | tree),
binomial, data = Shipley)
)
Shipley.SEM
?nobs
AIC(Shipley.SEM2$Live)
AICc(Shipley.SEM2$Live)
?AICc
?resid
?resid.merMod
?residuals.glm
?residuals.lm
logLik.mer
is.na("a")
?predict.merMod
predict(Shipley.SEM2$Live, re.form = NA) == predict(Shipley.SEM2$Live, re.form = NA)
all(predict(Shipley.SEM2$Live, re.form = NA) == predict(Shipley.SEM2$Live, re.form = NA))
all(predict(Shipley.SEM2$Live, re.form = NA) == predict(Shipley.SEM2$Live, re.form = ~0))
NA > 0
View(Shipley.SEM)
View(Shipley.SEM)
Shipley.SEM
Shipley.SEM.boot <- bootSEM(Shipley.SEM, ran.eff = "site", R = 1000)
Shipley.SEM.boot <- bootSEM(Shipley.SEM, ran.eff = "site", R = 1000)
Shipley.SEM.boot <- bootSEM(Shipley.SEM, ran.eff = "site", R = 1000)
warnings()
bootCI( Shipley.SEM.boot)
save(Shipley, Shipley.SEM, Shipley.Live, Shipley.SEM.boot, file = "Shipley.rda")
Shipley.SEM
Shipley.Live
library(semEff)
save(Shipley, Shipley.SEM, Shipley.Live, Shipley.SEM.boot, file = "Shipley.rda", compress = "xz")
library(semEff)
library(semEff)
library(semEff)
library(semEff)
library(semEff)
library(semEff)
library(semEff)
library(semEff)
library(semEff)
library(semEff)
library(semEff)
library(semEff)
scale(Shipley)
library(semEff)
library(semEff)
library(semEff)
library(semEff)
## Using new data for 'lat'
nd <- with(na.omit(Shipley), expand.grid(
lat = seq(min(Growth), max(Growth), length = 100),
DD = mean(DD),
Date = mean(Date),
Growth = mean(Growth)
))
f.dir <- predEff(m, nd, dir, type = "response")
f.tot <- predEff(m, nd, tot, type = "response")
library(semEff)
library(semEff)
getY <- function(m, family = NULL, data = NULL, link = FALSE, ...) {
f <- family; d <- data
## Function
getY <- function(m) {
## Update model with any supplied data and/or family
mod <- isMod(m)
if (mod) {
if (!is.null(d)) m <- eval(update(m, data = d, evaluate = FALSE))
if (!is.null(f)) m <- eval(update(m, family = f, evaluate = FALSE))
}
## Model response
y <- if (mod) {
y <- fitted(m) + resid(m, "response")
w <- weights(m)
if (!is.null(w)) y[w > 0] else y
} else {
y <- as.numeric(m)
setNames(y, names(m))
}
## Return in original or link scale
if (isGlm(m) && link || !mod && !is.null(f)) {
## Transform to link scale
yl <- if (mod) {f <- family(m); f$linkfun(y)}
## Return the transformed (or working) response
if (!mod || any(is.infinite(yl))) {
y2 <- y
# suppressWarnings(
m <- do.call(glm, list(y ~ y2, f, control = list(maxit = 1)))
# )
f <- m$family
if (!mod) yl <- f$linkfun(y)
if (any(is.infinite(yl))) {
i <- 0
repeat {
yl <- predict(m) + resid(m, "working")
yli <- f$linkinv(yl)
eql <- isTRUE(all.equal(yli, y, check.names = FALSE))
if (eql) return(yl) else {
i <- i + 1
# suppressWarnings(
m <- update(m, . ~ yl, control = list(maxit = i))
# )
}
}
} else yl
} else yl
} else y
}
## Apply recursively
rMapply(getY, m)
}
getY <- function(m, family = NULL, data = NULL, link = FALSE, ...) {
f <- family; d <- data
## Function
getY <- function(m) {
## Update model with any supplied data and/or family
mod <- isMod(m)
if (mod) {
if (!is.null(d)) m <- eval(update(m, data = d, evaluate = FALSE))
if (!is.null(f)) m <- eval(update(m, family = f, evaluate = FALSE))
}
## Model response
y <- if (mod) {
y <- fitted(m) + resid(m, "response")
w <- weights(m)
if (!is.null(w)) y[w > 0] else y
} else {
y <- as.numeric(m)
setNames(y, names(m))
}
## Return in original or link scale
if (isGlm(m) && link || !mod && !is.null(f)) {
## Transform to link scale
yl <- if (mod) {f <- family(m); f$linkfun(y)}
## Return the transformed (or working) response
if (!mod || any(is.infinite(yl))) {
y2 <- y
suppressWarnings(
m <- do.call(glm, list(y ~ y2, f))#, control = list(maxit = 1)))
)
f <- m$family
if (!mod) yl <- f$linkfun(y)
if (any(is.infinite(yl))) {
i <- 0
repeat {
yl <- predict(m) + resid(m, "working")
yli <- f$linkinv(yl)
eql <- isTRUE(all.equal(yli, y, check.names = FALSE))
if (eql) return(yl) else {
i <- i + 1
suppressWarnings(
m <- update(m, . ~ yl)#, control = list(maxit = i))
)
}
}
} else yl
} else yl
} else y
}
## Apply recursively
rMapply(getY, m)
}
getY <- function(m, family = NULL, data = NULL, link = FALSE, ...) {
f <- family; d <- data
## Function
getY <- function(m) {
## Update model with any supplied data and/or family
mod <- isMod(m)
if (mod) {
if (!is.null(d)) m <- eval(update(m, data = d, evaluate = FALSE))
if (!is.null(f)) m <- eval(update(m, family = f, evaluate = FALSE))
}
## Model response
y <- if (mod) {
y <- fitted(m) + resid(m, "response")
w <- weights(m)
if (!is.null(w)) y[w > 0] else y
} else {
y <- as.numeric(m)
setNames(y, names(m))
}
## Return in original or link scale
if (isGlm(m) && link || !mod && !is.null(f)) {
## Transform to link scale
yl <- if (mod) {f <- family(m); f$linkfun(y)}
## Return the transformed (or working) response
if (!mod || any(is.infinite(yl))) {
y2 <- y
# suppressWarnings(
m <- do.call(glm, list(y ~ y2, f, control = list(maxit = 1)))
# )
f <- m$family
if (!mod) yl <- f$linkfun(y)
if (any(is.infinite(yl))) {
i <- 0
repeat {
yl <- predict(m) + resid(m, "working")
yli <- f$linkinv(yl)
eql <- isTRUE(all.equal(yli, y, check.names = FALSE))
if (eql) return(yl) else {
i <- i + 1
# suppressWarnings(
m <- update(m, . ~ yl, control = list(maxit = i))
# )
}
}
} else yl
} else yl
} else y
}
## Apply recursively
rMapply(getY, m)
}
?get
is.character(NULL)
getY <- function(m, family = NULL, data = NULL, link = FALSE, ...) {
f <- family; d <- data
## Function
getY <- function(m) {
## Update model with any supplied data
mod <- isMod(m)
if (mod && !is.null(d)) {
m <- eval(update(m, data = d, evaluate = FALSE))
}
## Model response
y <- if (mod) {
y <- fitted(m) + resid(m, "response")
w <- weights(m)
if (!is.null(w)) y[w > 0] else y
} else {
y <- as.numeric(m)
setNames(y, names(m))
}
## Return in original or link scale
if (isGlm(m) && link || !mod && !is.null(f)) {
## Error family
f <- if (is.character(f)) {
get(f, mode = "function", envir = parent.frame())
} else {
if (is.null(f)) family(m) else f()
}
## Transform response to link scale
yl <- f$linkfun(y)
## Return the transformed (or working) response
if (any(is.infinite(yl))) {
y2 <- y
suppressWarnings(
m <- do.call(glm, list(y ~ y2, f, control = list(maxit = 1)))
)
i <- 0
repeat {
yl <- predict(m) + resid(m, "working")
yli <- f$linkinv(yl)
eql <- isTRUE(all.equal(yli, y, check.names = FALSE))
if (eql) return(yl) else {
i <- i + 1
suppressWarnings(
m <- update(m, . ~ yl, control = list(maxit = i))
)
}
}
} else yl
} else y
}
## Apply recursively
rMapply(getY, m)
}
glm
glm
library(semEff)
library(semEff)
library(semEff)
?glmer
library(semEff)
devtools::run_examples()
?\devtools::run_examples
?devtools::run_examples
?devtools::run_examples(start = predEff.Rd)
devtools::run_examples(start = predEff.Rd)
devtools::run_examples(start = predEff)
devtools::run_examples(start = "predEff")
devtools::run_examples(start = "predEff")
devtools::run_examples(start = "predEff")
devtools::run_examples(start = "predEff")
devtools::run_examples(start = "predEff")
?eval
devtools::run_examples(start = "predEff")
devtools::run_examples(start = "predEff")
getData(m, subset = TRUE, merge = TRUE
devtools::run_examples(start = "predEff")
devtools::run_examples(start = "predEff")
library(semEff)
devtools::run_examples(start = "predEff")
library(semEff)
devtools::run_examples(start = "predEff")
devtools::run_examples(start = "predEff")
devtools::run_examples(start = "predEff")
devtools::run_examples(start = "predEff")
devtools::run_examples(start = "predEff")
devtools::run_examples(start = "predEff")
devtools::run_examples(start = "predEff")
devtools::run_examples(start = "predEff")
devtools::run_examples(start = "predEff")
devtools::run_examples(start = "predEff")
devtools::run_examples(start = "predEff")
devtools::run_examples(start = "predEff")
devtools::run_examples(start = "predEff")
library(semEff)
devtools::run_examples(start = "predEff")
devtools::run_examples(start = "predEff")
library(semEff)
library(semEff)
devtools::run_examples(start = "predEff")
library(semEff)
devtools::run_examples(start = "predEff")
devtools::run_examples(start = "predEff")
library(semEff)
library(semEff)
devtools::run_examples(start = "predEff")
library(semEff)
devtools::run_examples(start = "predEff")
library(semEff)
devtools::run_examples(start = "predEff")
library(semEff)
devtools::run_examples(start = "predEff")
library(semEff)
devtools::run_examples(start = "predEff")
library(semEff)
devtools::run_examples(start = "predEff")
library(semEff)
devtools::run_examples(start = "predEff")
devtools::run_examples(start = "predEff")
library(semEff)
devtools::run_examples(start = "predEff")
library(semEff)
library(semEff)
devtools::run_examples(start = "predEff")
library(semEff)
sqrt(VIF(m2))
devtools::run_examples(start = "predEff")
library(semEff)
devtools::run_examples(start = "predEff")
library(semEff)
devtools::run_examples(start = "predEff")
library(semEff)
devtools::run_examples(start = "predEff")
devtools::run_examples(start = "predEff")
library(semEff)
devtools::run_examples(start = "predEff")
devtools::run_examples(start = "predEff")
library(semEff)
library(semEff)
devtools::run_examples(start = "predEff")
library(semEff)
devtools::run_examples(start = "predEff")
library(semEff)
devtools::run_examples(start = "predEff")
devtools::run_examples(start = "predEff")
library(semEff)
?setNames
setNames(NA, "a")
NA == "matrix"
if(NA == "matrix") "mat" else "no"
library(semEff)
devtools::run_examples(start = "predEff")
all(c(TRUE, TRUE)); all(c(TRUE, TRUE, NULL))
all(c(TRUE, FALSE, NULL))
c(TRUE, TRUE, NULL)
sapply(c("a" = 1, "b" = 2, "c" = 3), function(i) {
if (i %in% c(1, 2)) i == 1
})
sapply(c("a" = 1, "b" = 2, "c" = 3), function(i) {
if (i %in% c(1, 2)) i == 1 else FALSE
})
rep(c(1, 2, 3), 2)
library(semEff)
devtools::run_examples(start = "predEff")
Shipley.SEM <- list(
"DD" = lme4::lmer(DD ~ lat + (1 | site) + (1 | tree), data = Shipley),
"Date" = lme4::lmer(Date ~ DD + (1 | site) + (1 | tree), data = Shipley),
"Growth" = lme4::lmer(Growth ~ Date + (1 | site) + (1 | tree),
data = Shipley),
"Live" = lme4::glmer(Live ~ Growth + (1 | site) + (1 | tree), binomial,
data = Shipley)
)
load(file = "Shipley.rda")
Shipley.SEM <- list(
"DD" = lme4::lmer(DD ~ lat + (1 | site) + (1 | tree), data = Shipley),
"Date" = lme4::lmer(Date ~ DD + (1 | site) + (1 | tree), data = Shipley),
"Growth" = lme4::lmer(Growth ~ Date + (1 | site) + (1 | tree),
data = Shipley),
"Live" = lme4::glmer(Live ~ Growth + (1 | site) + (1 | tree), binomial,
data = Shipley)
)
Shipley.Growth <- list(
lme4::lmer(Growth ~ Date + (1 | site) + (1 | tree), data = Shipley),
lme4::lmer(Growth ~ Date + DD + (1 | site) + (1 | tree), data = Shipley),
lme4::lmer(Growth ~ Date + DD + lat + (1 | site) + (1 | tree),
data = Shipley)
)
save(Shipley, Shipley.SEM, Shipley.Growth, Shipley.SEM.boot, file = "Shipley.rda",
compress = "xz")
save(Shipley, Shipley.SEM, Shipley.Growth, Shipley.SEM.boot, file = "Shipley.rda",
compress = "xz")
library(semEff)
system.time(Shipley.SEM.boot <- bootSEM(Shipley.SEM, ran.eff = "site", seed = 53908))
Shipley.SEM.boot
system.time(Shipley.SEM.boot <- bootSEM(Shipley.SEM, ran.eff = "site", R = 1000, seed = 53908))
## Save data
save(Shipley, Shipley.SEM, Shipley.Growth, Shipley.SEM.boot, file = "Shipley.rda",
compress = "xz")
## Save data
save(Shipley, Shipley.SEM, Shipley.Growth, Shipley.SEM.boot, file = "Shipley.rda",
compress = "xz")
system.time(Shipley.SEM.boot <- bootSEM(Shipley.SEM, ran.eff = "site", R = 10000, seed = 53908))
3250.67 /60
save(Shipley, Shipley.SEM, Shipley.Growth, Shipley.SEM.boot, file = "Shipley.rda",
compress = "xz")
save(Shipley, Shipley.SEM, Shipley.Growth, Shipley.SEM.boot, file = "Shipley.rda",
compress = "xz")
library(semEff)
library(semEff)
Shipley.SEM.boot$DD$R
bootCI(Shipley.SEM.boot)
semEff(Shipley.SEM.boot)
?lme4:::predict.merMod
library(semEff)
semEff(Shipley.SEM.boot, predictors = "lat")
semEff(Shipley.SEM.boot, mediators = "DD")
semEff(Shipley.SEM.boot, responses = "Live")
semEff(Shipley.SEM.boot, mediators = "DD")
bootCI(Shipley.SEM.boot)
Shipley.Growth
R2(Shipley.SEM)
R2(Shipley.SEM, re.form = NA)
stdCoeff(Shipley.SEM)
0.3824224^2
R2(Shipley.SEM, re.form = ~ (1 | site))
R2(Shipley.SEM, re.form = ~ (1 | tree))
R2(Shipley.SEM) - R2(Shipley.SEM, re.form = NA)
piecewiseSEM::rsquared(Shipley.SEM)
cbind(R2(Shipley.SEM, re.form = NA)[, 1], R2(Shipley.SEM)[, 1])
cbind(R2(Shipley.SEM, re.form = NA)[1, ], R2(Shipley.SEM)[1, ])
piecewiseSEM::rsquared(Shipley.SEM)[5:6]
library(semEff)
?`:::`
lme4:::isRE
lme4::findbars(formula(Shipley.SEM$DD))
blah <- ~0
identical(blah, ~0)
identical(blah, ~ 0)
str(~ 0)
library(semEff)
!is.na(NULL)
is.null(NA)
identical(NULL, ~ 0)
identical(NULL, NA)
blah <- NA
identical(blah, NA)
library(semEff)
library(semEff)
library(semEff)
semEff(Shipley.SEM.boot$DD)
semEff(list(Shipley.SEM.boot$DD))
list(Shipley.SEM.boot$DD)
semEff(Shipley.SEM.boot[1])
direct(semEff(Shipley.SEM.boot[1]))
d <- na.omit(Shipley)
xn <- c("Growth", "DD")
d[xn] <- scale(d[xn])  # standardise predictors (improves fit)
m <- lme4::glmer(Live ~ Growth * DD + (1 | site) + (1 | tree),
family = binomial, data = d)
system.time(m.eff <- semEff(list("Live" = m), ran.eff = "site"))
system.time(m.eff <- semEff(list("Live" = m), ran.eff = "site"))
system.time(m.eff <- semEff(list("Live" = m), ran.eff = "site", R = 100))
system.time(m.eff <- semEff(list("Live" = m), ran.eff = "site", R = 10))
system.time(bootSEM <- list("Live" = m), ran.eff = "site", R = 10))
system.time(bootSEM(m, ran.eff = "site", R = 10))
attr(blah)
